<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Composition of GUI and Drawing graph</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>
<div id="main">
<h1>Composition of GUI and drawing graph</h1>
<p>In java, Abstract Window Toolkit（AWT）had first developed for composing Graphical User Interface
(GUI), and it supplies the following functionals:</p>
<ul>
<li>Rich set of components for developing interactive user interface</li>
<li>Solid model of event handler</li>
<li>Toolkit of graphics and image processing including figure, color, and font</li>
<li>Layout manager that can layout window independent of the size and resolution of images</li>
<li>Data transfer class that can cut and paste them through the clipboard of native platform</li>
</ul>
<p>
The extension of AWT is developed as <b>Swing</b> library consisting of advanced set of components
such as tree display, listbox, and tabbed pane. This exercise introduce the example of GUI based on the Swing.</p>
<p class="Caution">Class names of Swing library has capital 'J' to distinguish them from AWTs'.</p>
<h2>GUI (Graphical User Interface) with Swing</h2>

<h3>Step 1. Non-responsive GUI</h3>

<p>This sample code displays a menu bar (JMenu) at the top of a window,
a message (JLabel) inside the window, and a button (JButton).</p>
<u>SimpleGUI.java:</u><!-- 実行確認済み -->
<pre class="SourceCode"><code>import java.awt.*;
import java.awt.Color;
import javax.swing.*;

public class SimpleGUI extends JFrame {
    private JLabel label; // メッセージを表示するラベル
    private JButton button; // ボタン
    private JMenuBar menubar; // 複数のメニューを表示するメニューバー
	
    public SimpleGUI () {
        //コンポーネントの作成
        label = new JLabel(&quot;Swing の世界へようこそ！&quot;); // テキストを表示する GUI 部品
        button = new JButton(&quot;OK&quot;); // ボタンを表示する GUI 部品
        String[] menuTitle = {&quot;項目１&quot;, &quot;項目２&quot;, &quot;項目３&quot;}; // メニューの表示項目
        menubar = new JMenuBar(); // メニューバーの生成
        JMenu menu = new JMenu(&quot;メニュー&quot;); // メニューの生成
        for (int n=0; n&lt;menuTitle.length;n++)
            menu.add(new JMenuItem(menuTitle[n])); // メニュー項目の登録
        menubar.add(menu); // メニューをメニューバーに追加
        
        add(label, BorderLayout.NORTH); // ラベルをコンテナの上部に追加
        add(button, BorderLayout.SOUTH); // ボタンをコンテナの下部に追加
        setJMenuBar(menubar); // メニューバーをコンテナに追加
        // JFrame に対する諸設定
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // ウィンドウが閉じられた際の処理
        setLocation (400, 200); // 画面内でのウインドウの左上隅の座標位置
        setSize (300, 300); // ウィンドウの大きさ
        setVisible(true); // 可視化する
    }
	
   public static void main(String[] args) {
       SimpleGUI frame = new SimpleGUI (); // フレームの生成
   }
}</code>
</pre>

<ul class="Point">
<li>JFrame class (or its derivative class) is used for constructing a base window, on which various components of GUI is arranged.</li>
<li>GUI is constructed by arranging parts of component onto a base container.</li>
<ul>
<li>JFrame makes a container by inheriting a Container class</li>
<li>Tex label (JLabel) and button (JButton) are components that inherit JComponent class</li>
<li>Container's method add() is used for arranging components on it.</li>
<li>BorderLayout.NORTH, BorderLayout.SOUTH are values for specifying the type of arrangement,
the BorderLayout is designed as class.</li>
<li>Component can arrange other components; JComponent class inherits Container class.</li>
</ul>
<li>Window with GUI is generated by instantiating the JFrame class and visualizing it by
setVisible(true), and it then waits the input signals from keyboard, mouse. and so on.</li>
</ul>

<h4>Appendix: Layout of components</h4>
<p>Layout manager class is used for arranging the components of GUI, which consists of 
<ul>
<li><a href="http://www.javadrive.jp/tutorial/borderlayout/">BorderLayout</a></li>
<li><a href="http://www.javadrive.jp/tutorial/flowlayout/">FlowLayout</a></li>
<li><a href="http://www.javadrive.jp/tutorial/gridlayout/">GridLayout</a></li>
<li><a href="http://www.javadrive.jp/tutorial/cardlayout/">CardLayout</a></li>
<li><a href="http://www.javadrive.jp/tutorial/boxlayout/">BoxLayout</a></li>
<li><a href="http://www.javadrive.jp/tutorial/gridbaglayout/">GridBagLayout</a></li> 
<li><a href="http://www.javadrive.jp/tutorial/springlayout/">SpringLayout</a></li>
</ul>
where example of display is shown
<a href="http://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html">here</a>
<br />
The components added to a container is arranged according to the Layout manager set at the container. 
(<a href="http://www.javadrive.jp/tutorial/ini/index3.html">Reference of Layout managers</a>）
</p>
<p class="Caution">
For hierarchically arranging components, JPanel can arrange the set of components
(<a href="http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html">refer for details</a>).
</p>

<h3>Step 2. Making event handler</h3>
<p>The above SimpleGUI class is extended to obtain some responses in pressing buttons or selecting buttons as,
</p>
<u>ボタンに対するイベントを追加した例</u><!-- 実行確認済み -->
<pre class="SourceCode">
import java.awt.*;
import javax.swing.*;
<b class="innerCaution">import java.awt.event.*;</b> // 追加する！

public class SimpleGUI extends JFrame {
    private JLabel label; // メッセージを表示するラベル
    private JButton button; // ボタン
    private JMenuBar menubar; // 複数のメニューを表示するメニューバー

    public SimpleGUI () {
        // 以下、SimpleGUI と同じ内容なので省略...

        // コンストラクタの末尾において、以下の様にボタン用の応答機能（リスナ）を登録する
        button.addActionListener(new ButtonActionListener());
        // コンストラクタの末尾において、以下の様にメニュー用の応答機能（リスナ）を登録する
        menu = menubar.getMenu(0);; // メニューの取得
        for (int i=0; i &lt; menu.getItemCount(); i++) {
            JMenuItem item = menu.getItem(i);
            item.addActionListener(new MenuActionListener()); // メニューの各アイテムにリスナを登録
        }
    }

    // ボタン用のリスナクラスを作成する
    class ButtonActionListener implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            label.setText(&quot;ボタンが押されました！&quot;); // label は private 変数だが参照できる
        }
    }
   
    // メニュー用のリスナクラスを作成する
    class MenuActionListener implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            label.setText(e.getActionCommand() + &quot;のメニューが選択されました！&quot;); // メニュー項目名を表示
        }
    }  
   
    public static void main(String[] args) {
        SimpleGUI  frame = new SimpleGUI(); // 上記の例と同じ内容
    }
}
</pre>

<ul class="Point">
<li>The responsive method called in selecting components is composed by implementing Listener interface.</li>
<ul><li>The listener class is registered to a component by calling its addActionListener method.</li>
</ul>
<li>The function of the listener is implemented by overriding a corresponding method such as actionPerformed.</li>
<ul>
<li>Listener class is supplied according to the component, for example, ActionListener is prepared for button component.</li>
<li>As Listener class is designed as interface, it is implemented (not extended), and all method must be implemented.</li>
<li>Responsive method is given by overriding the method of subclass such as ActionListener.</li>
</ul>
<li>Responsive method receives the content of the event by the parameter of ActionEvent.</li>
<ul>
    <li>The parameter can be unused.</li>
</ul>
</ul>

<p class="Caution">
The above example declares ButtonActionListener and MenuActionListener classes inside the SimpleGUI class.
This type of definition is called inner class (<a href="http://www.javaroad.jp/java_class15.htm">click here for details</a>),
and the inner class can refer the private fields such as label, button of the parent (SimpleGUI) class.</p>

<h3>Step 3. Drawing figures</h3>
<p>Figures are drawn by overriding the method <code>void paint (Graphics g)</code> of JPanel class.<br/>
Actually, the parameter of <code>Graphics g</code> calls method for drawing figures;
drawing a circle whose radius is 100, is drawn by calling<br>
<code>g.drawOval(0, 0, 100, 100)</code><br>

The class for drawing arc is given as follows,</p>
<pre class="SourceCode"><code>
    class ArcGraphics extends JPanel { // JPanel を継承する
        private Color col [] = {Color.RED, Color.GREEN, Color.BLUE, Color.CYAN, Color.MAGENTA, Color.YELLOW}; // 描画色
        private String itemTitle[] = {&quot;項目１&quot;,&quot;項目２&quot;,&quot;項目３&quot;,&quot;項目４&quot;,&quot;項目５&quot;,&quot;項目６&quot;}; // 項目名
        
        public ArcGraphics () {
            setSize(300, 250); // このパネルの大きさを指定
        }
        
        public void paint (Graphics g) {
            int offset = 0, deg = 30; // 単純な例として３０度刻みの弧を描く
            for (int i = 0; i &lt; itemTitle.length; i++) {
                g.setColor(col[i]); // 色の設定
                g.fillArc(75, 50, 200, 200, offset, deg); // 左上隅のx,y座標、弧の幅と高さ、開始角度、展開角度を順に指定する
                g.drawString(itemTitle[i], 10, 50+20*i); // 項目名を表示
                offset += deg; // 開始角度を更新
            }
        }
    }
</code></pre>
<p>
Display this class requires registering it on parent component, for example, the above SimpleGUI class as,
<pre class="SourceCode">
ArcGraphics arcG = new ArcGraphics();
<code>add(arcG, BorderLayout.CENTER); // ウインドウの中央に配置
</code></pre>    
where the ArcGraphics can be implemented as inner class of SimpleGUI.<br>
The method <code>updateUI()</code> of JPanel is called for updating the display of <code>arcG</code> as,
<pre class="SourceCode">
<code>arcG.updateUI(); // ArcGraphics の描画内容を更新    
</code></pre>
<br>
More references:<br>
<a href="http://www.javadrive.jp/applet/graphics/">【Graphics class for drawing figures】</a><br>
<a href="http://www.javadrive.jp/tutorial/">【Fundamentals of Swing】</a>
</p>
<br />
<div class="Exercise">
<h4 id="Exercise">Exercise 3. GUI and pie graph</h4>
<p>
前回の課題２で作成したプログラムの入出力を、ＧＵＩを用いた対話的な操作で実行するプログラム（GUI.java）を、以下の仕様に従って作成する。<br>
</p>

<h4>入力操作（ＧＵＩ）</h4>
<ul>
<li>条件の項目と値を複数のＧＵＩを用いた選択操作だけで指定できる様にする。ただし、階層的なメニュー（構築方法は、<a href="#HierarchicalMenu">以下の補足１</a>を参照の事）や、排他的選択が可能なボタン群（<a href="http://www.javadrive.jp/tutorial/jradiobutton/">JRadioButton</a>：構築方法は <a href="#RadioButton">以下の補足２</a>を参照の事）を用いても良い。</li>
<li>複数の条件を与える際には、論理和か論理積を別のメニューやボタン等で選択させる。ただし、選択しなかった場合のデフォルト値は論理和とする。</li>  
<li>円グラフの表示機能は、実行用ボタンを押下した際に呼び出されるものとする。</li>
<li>ＧＵＩの部品選択と配置は、操作の分かりやすさと容易さを心がけてデザインする。</li>
</ul>

<h4>出力表示（円グラフ）</h4>
<ul>
<li>メニューで選択した条件をテキストで表示する。ただし、複数の条件を選択した場合はそれらの和か積の論理条件も添えて全条件を表示する。</li>
<li>ボタンが押された際に、以下の様な出力結果：
<pre class="CommandLine">
unacc = 10, acc = 23, good = 45, vgood = 67
</pre>
の各値の割合を、色付きの円グラフで表示する。</li>
</ul>

<h4>シリアライズ保存／読出【この機能は省略しても良いが、無い場合は若干の減点となる】</h4>
<p>読み込んだ表形式のデータを格納するクラス（ArrayListやそれを拡張したもの）をシリアライズできる様にし（implements Serializable を宣言する）、そのクラスオブジェクト自体をファイルに保存／読出しできるように実装する。ただし、ファイルの指定はダイアログ部品である<a href="http://www.javadrive.jp/tutorial/jfilechooser/"> JFileChooser </a>を使用する（ただし，<b class="innerCaution">Serializable に関する説明は，トピック集の「<a href="./Topics.html#Object">３．オブジェクト（Object）クラス</a>」を参照</b>する事）。保存や読み出し機能の選択はメニューバーに新たなメニューを追加する。
</p>
</div>
<br>

<h3><a name="HierarchicalMenu">Appendix 1. Hierarchical composition of menu</a></h3>
<p>For hierarchically compositing a menu, <code>add(Component c)</code> submenu <code> c </code>,
instead of JMenuItem as,
</p>
<u>Simple example of hierarchical menu</u> <!-- 実装動作確認済み -->
<pre class="SourceCode">
<code>String[] menuTitle = {&quot;項目１&quot;, &quot;項目２&quot;, &quot;項目３&quot;}; // メニューの表示項目
String[] subTitle = {&quot;詳細１&quot;, &quot;詳細２&quot;}; // サブメニューの表示項目
menubar = new JMenuBar(); // メニューバーの生成
JMenu menu = new JMenu(&quot;メニュー&quot;); // メニューの生成
for (int n=0; n&lt;menuTitle.length;n++) {
    JMenu subMenu = new JMenu(menuTitle[n]); // サブメニューの生成
    for(int s=0; s&lt;subTitle.length; s++) {
        JMenuItem item = new JMenuItem(subTitle[s]);
        subMenu.add(item); // サブメニュー項目の登録
        item.addActionListener(new MenuActionListener()); // サブメニューの各アイテムにリスナを登録
    }
    menu.add(subMenu); // サブメニューの登録
}
menubar.add(menu); // メニューをメニューバーに追加
</code></pre>

<br>
<h3><a name="RadioButton">Appendix 2. Panel of a group of Radio buttons</a></h3>
<p>The below sample code compose a panel for selecting only a signle item from multiple buttons.</p>
<u>Simple composition of a group of radio buttons</u> <!-- 実装動作確認済み -->
<pre class="SourceCode">
<code>class RadioButtonSelector extends JPanel { // ラジオボタンによる条件設定用のパネル構築例クラス
    private ButtonGroup group;

    public RadioButtonSelector () {
        setLayout(new GridLayout(1,0)); // １行に収める格子状配置
        group = new ButtonGroup();
        String ItemsLabel[] = {&quot;項目１&quot;, &quot;項目２&quot;,&quot;項目３&quot;};
        MenuActionListener maListener = new MenuActionListener();
        setLayout(new GridLayout(0,1));
        add(new JLabel(&quot;メニュー&quot;));
        for (int n=0; n&lt;ItemsLabel.length;n++) {
            JRadioButton button = new JRadioButton(ItemsLabel[n]);
            if (n==0)
                button.setSelected(true); // デフォルトとして選択されるボタン
            button.addActionListener(maListener); // リスナを登録
            add(button); // ボタンをパネルに登録
            group.add(button); // ボタンをラジオボタンのグループとして登録
        }
    }
    //リスナクラス
    class MenuActionListener implements ActionListener {
        public void actionPerformed(ActionEvent e) {
            String action = e.getActionCommand(); // このメニューが選択された際の項目名を取得
            System.out.println(action);
        }
    }
}
</code></pre>
<br><br>
<h3>Appendix 3. Convenient composition of event handler with Adapter classes</h3>
<p>
Listener class for handling mouse and keyboard events have many method to be implemented, which often include
unnecessary method such as*
<ul>
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/awt/event/MouseListener.html">for MouseListener</a>: mouseClicked, mousePressed, mouseReleased, mouseEntered, mouseExited</li>
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/awt/event/KeyListener.html"> for KeyListener</a>:  keyTyped, keyPressed, keyReleased</li>
</ul>

Java library supplies Adapter class that is defined by implementing listener class and its all default methods.
Listener-based object can be composed by overriding only utilized method by inheriting (extending) the Adaptor class.

</p>
<u>Event handler of keyboard and mouse with Adapter</u><!-- 実行確認済み -->
<pre class="SourceCode">
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class InputAdapter extends JFrame {
   private JLabel label;

   public InputAdapter () {
      label = new JLabel("Swing の世界へようこそ！");
      add(label, BorderLayout.NORTH);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLocation (400, 200); 
      setSize (300, 300);
      setVisible(true);
      //リスナの登録
      <b class="innerCaution">addMouseListener(new SampleMouseListener());</b> // マウスボタン操作に対するリスナー
      <b class="innerCaution">addKeyListener(new SampleKeyListener());</b> // キーボード操作に対するリスナー
   }

   //リスナクラス
   class SampleMouseListener <b class="innerCaution">extends MouseAdapter</b> {
      public void mouseClicked(MouseEvent e) {
         label.setText("マウスボタンが押されました");
      }
     public void mouseEntered(MouseEvent e) {
         label.setText("マウスポインタがウインド内に入りました");
      }
      public void mouseExited(MouseEvent e) {
         label.setText("マウスポインタがウインド外に出ました");
      }
   }

   class SampleKeyListener <b class="innerCaution">extends KeyAdapter</b> {
      public void keyPressed(KeyEvent e) {
         String str;
         int k = e.getKeyCode();
         switch(k){
            case KeyEvent.VK_UP:
              str = "上"; break;
            case KeyEvent.VK_DOWN:
              str = "下"; break;
            case KeyEvent.VK_LEFT:
              str = "左"; break;
            case KeyEvent.VK_RIGHT:
              str = "右"; break;
            default:
              str = "他のキー";
         }
         label.setText(str + "が押されました");
      }
   }

   public static void main(String[] args) {
       InputAdapter frame = new InputAdapter (); // フレームの生成
   }
}
</pre>


</div>

</body>
</html>